<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"522e7cd7d7ddb87706c7396a9d3e1f82e2353eb36f3e7b8e941ee4438d0841fd67614ad62290cb721f930861913a1e3a9622ca8a8b3785239f19e6b898ebd1b059fb01585ef95b56163db97a17026848d86c86d909d1eea511597c9cbae9ea0c4384b9ef96ddf3c76858f592bd140302534a2cb07779819c027db7ce548b816ed9defe00b5d7cfb5de030f95f4c80f48813127726bb8be6acb83055489a40f8211b1b4f6bbdb0b8b215ab37308069e234e47379ad841678ac320b712945976662ce5a8c7c9f5a8b94dcc4ea25f30cc86a4f0cbce1d09be48d8b1699d3b6f9dcc2c8be9f3a904162cccec7b87eb7c601517086ef3da56a9944c8915f28efdd6220a8b0cf1e19ccf479690c4332643928ae82bf58b04e5ba47ed9b115973031c2b2257926676c77689ad74734dc235308bfbd540df3985dab3b8f4d24a0f757a0d7e818d7262689ea4c60aee5ea3bf594cb75465a65a3d8c150f61a7e00f7a32d0f1e2f4053532f2e5d66fa1df5d1fedab0ca2ae8a2ed1bebef93ac15b3418877919f5c28048ccf20413605591c41a26af45faac9a7841fad21650872ae708aeba81ce21aa4f2b17a743777e5558db5703dde7237ee1727f898d19c0b1391aa3e77113a867c8bb09df660c5121d6e6e6f9f8cf13fd0e5f06e57d9a9260e848dbca5b26c8ba7273adf6055b9517b081f1dc47fa389235e81beaae39d7ab84c865d4a1c5f857e390957da1e4670f94f04a77f4559b4c998f5a2c3a206bc3de12c4142963bd28586b422e01d0709b4fafea705d093fbdffd655ec50efde493a29939e7fc51ee7012ee0142ba5c332cb54a516c58674c1a351949dcd8596020a5b48742941b430d3160db01ca7de09ae9e4c92ee82597fd2d1f3735da0e3d4b2656421eba4d8d2abd697c7ce3b7685cc6a79afe6e2fb8e88ed944ec3371b4ccb77deeed65d5dfc619b73af8cd6f57acac4f1fe79cd9a2c0ee4d63314ed7f496534d0ace60165080d22534110a34b9ba8d2264ab7889b9d66d82d4af5bcb408ea364dfc867103841e690b6a5aba4238f6d6e13f545598cf1bdfe06f747cbfc600a18418aec6f916a85da0c89c5b65e3be697a6243d9532435e3929f284ad81fcad989c5e76507253d8c6de6386632fb788f97c11b4f07bb0de22f9785f7d64c8f56829ff6c8ba212a81443e5ee3b40b0f304cb3723a3b9939876d0792cf99088f43859f4665c7f374ba5949b731c095f69a3bc658ca994b373eeef4977cddafac4ae0c8c148691a318526b2aad411478af5eebf7037ba41b131c4e56c26e2284c05bb2ac1f0fcfc38faddbefa16caa163a77f81d3507ba6dff0d3a74c6c15ee466d97125b3d73ec0dde2ad1c2540f9247cca77a2f8ea153bc861e50b40836abff79c299a3a7c4e43ad5326818adeb04b3247d1da5cb50552e915f4f3b39351d71d940c8448d5a804bb00230fa0203c8b16f390a8df8f49bbb7cd56082d9fe566affdca66a21be48adf2f79a9eb6ab626e947d0847f1f3f1efb4aef42f797fc158827c8d62b6f770b2ff47bbcdf4327fa86ffe646813e60946cff02cae4fc2b9716e9a6c32c38f11dc32689c096aa04d7929f5cf53915bc16cce8cfb29d06f1370800afa3ff495dd699713c74fd84fd68f78e2bcc92f4ed1844b8fb03927aba02d25956381fc0c246e5ff45ad18de8388a397131c2921be35bc462cdce71ed551ee498baafc13b8c2c01cc9b473fd5f3fdd6c6b69a697c6e702b3f83b4fef35381feba28a71ea39f5ca2af558da84817a95da5ebe16ee22cdf3f5d92d1abed5a5584171162d7110a441163eb27677929ee7b82556d63126af3ec53d81232bc5389bc14749295d07c16a2507bebbf307f6578bc34fc29d8274fc2e10563d4a01d3bcc389f9258a3dfc900da47f83adeef58ae2ad5cb240341797a777975fbfef618a31ef83866b7d5604fc25d13737d11aea5f89036ecd0be22966f85d1336f127cea7c658f67ff63e262a165fc1ed543325ec8dfd6eaf68deaad02f7927d067ffc97efd39f0ed4dca5e114be039e5c1d7cf9b86a93de9be9c22cbd67c494e19953531aa1984bdb9a2e808863e643aec8986d2f85472269258f683f694fd1e2354a13277080cc5d6623e9c7bf15253d3ae75ef36f1463ae27a93a4ee940c2bbc0b36c5c4be4f4509c6d6f22f4b9f41338363125b898b037879237e7f4d8595485d1214e7e7e09fb7b47beade5e3ae42c3b0fceecf9f36585fcfcba6d8f33b3950866cbbf3a68d94d7cb71f4289ba65b0033bb731218006f61053f7b02cf8d7adcd622dd449ab5d2f3b6102a2696c33bc8c79bf0d8a2bc2bcc68216cad23b997b394a420b69010a98e7f267a6e20e30dad8a9240f4b1956abfd201831de7973c2f2c4869a69a750ab027aaaa7f90803b1fe913b56aa0506b69de1e82b586d03d0a16147471f683df6c5947ac63bcd37f5d95f4e792e4aeb49ca572f0faf5eed7115ee5fc5afbed0898b0b8db73237be02c63a5bc60e516df26433175f7274bbba5ae50a55020033fbd208ca64c4ff2868849d9de975fd291053fdfad71701133a3317c7a235fe60741bbb7c17b2027798d87ff94da979107263ef7fcd619586a3b9b3c89f15fbf2b7cd14ca02c25983ad1f5f94649ba9cf8cd9d3105504bb60165bd23ba140cac4b4deb59241c27bf843fc26d628b80de306beba83b66c73b4ee7a6d20ecd47823c1bdfad22f786635f129d8c8477ed7eeaad9ff4d91ebc3d26670b24712bc3d705632f41dc5c0391dc29d1cb061b6bf5acc7993e9c447a246a071c2dfbf122ae1e84e979be7bf05cf3f1b91a7d12270b52fbe5071eab2047612d3669127580b780c49f7b9837eed690eeb40bcb219568ed17f44f2f5d51853ae21581c7d26ed604959f0373d19d31c0829a96941e8ce82f208a21ce4ab43fe30cfa67db4945c9ed263b876811f29139bf87fea8320117813bc8399c7107ce9d5f4c139530ad83b802d4a6ebe0ba40fafe07725bff4b97835634af2d9357d7f2944057f5fb8e72ad6123fc7a1f3bf19aaa12e34ee176fdd2019ecd538622ca071dd9262c2df41e1db2e48535727af35519b7bb1444aa02d38e2484b465915f7a5ef643596f38615412723b3efb617a3abd3be09b575be1141c9c3a777380088d45e4dc62aacfbd133eb875b13bcfcaea7a63e054bb5226514f4a30fd692d3d6bc739e15b140c66c679c6a73fdb63dc84856000f4ae00de6173ea44c417c1cfa7c64a8d804e5bcb9ef09579e5a2622052f1511529dcc9cafc41d87540667007819d8efbe1378620006981b39a80405709058cb070667e9f4d36569802db6f55845f654c42a7f3f4409bf947c2e07e6abecb3c1de51a8170297be4c4b5c2f38f09f1369494b85a123f9c866622d7ac211ae6edeab5b75bee1b596dd8ed81656f12a2605a8837a35a8782f91222bedb94aec3eea3a2792c90f6f564a59a160243ccf3f725ca9323664c52bbbb44e4726718e6819ec75571dfe126a271d926bf8ab11cad8c16302ff414bdee721dadeafc687354342c12c37a2b5f3a19824dfd5fed90d60c6f83f835301ddcde3d1da4278cdf8161049ea0b55f5e6b94f29513a258b62ca3087d29244fb76d3c21e05dbc79885ac3d0804cdbd71ac0c86b6e75c849eec7f17990881955a09d7fb6a8e3a39f478ec747d42d0da392c3c7e04f9459f16e0082f31f77a79670720ef7c1dce5c361c34b887698d17283d30d966520783222a9d4a1536b6b200090ee501f36548fb68197b6183683310fd786384b37bf59562b62f51f6d7561b62a397f5e939546d6ff7aaa23fe2e09d85e2f5affe135d4de598f3a7ba8b2de383db4c5d3121d0c4bae8942b2adf15a0d86c37b39172d7234db92c141b2fea5d0d9e773ef4a621e118c9b46d9569235c874bca0d74003f3480b16e7f4cb0623e8cecb15eba8a4986388be31d9b311117978a8f42172ef801a10d02535cf782de8f62c7ac5c3d2706d6d29768f5db9e6bbbfd45d86878a7d4ee4344da7a9e38f5932bf5052e08f6f8949ff83af3696e5d46f94c795d0c08d56ba55ebb8a660171b590b705bbb39e0be4d5b8e59d7f5f64fe41b7a452972b6b1346d7d86a842a476411f7d7ca2dbf906176ca2c6fbc209dfef4bf444b75d701012570382395c91a520fde23800a0a352d89753d86ad29a11ab730acacdedc887ee9d762c6c00439d11ad0e239759939e9c5fc59dcb57fce5de390c350f4c4e7eddd410a7eee09668cb651b4beee90249af857b1fef70fa9ffc57d556728f209d55f0748f5d5730390eb5942c081f1c86a1539e9bd92c167cd23bc2d15351f5888790ce65a0866cee1812bbbd89fd45d3f9f1fcda8ba41766e2758b72102a30d604769e1505f390c8e0149a4093d3935117187059fc5544820b5e269367a805eb8f0c8ba4e50218ae395af5157d02243e795dca256c765f66aabbb892a6eb53a2e5ab6532640e8a48603a470e6378aea0a9a95584e220628bde7028a11c6531690d69004b79d3112aba89c5365922db673b6c526faf822fc6e251c2cee576f2f3edf949aab81d3b1acecafba4ea8bba0c05286d778118e4fd9a3cffc897de7293cfb3d4b7346fde96b1e40ba6d9e9e95222bc4260d865b92e2267f2337b8d3672849800da15b5e8315d9ee70aa89fc86fbd404b17a5f1383788fd62ca4eeecd9327f139dac2550ae83229844f3104950f347611b9fbdd842aae82d162ada7101b5165eaf7b043f91e37034b6a908a741e7a72235bd23d40194230395920e28d0fd481c87d0300c7ad0aa21c031f95bdccfc985a1e135334699bc2012befd243f31bcbcc9767a900069ff7c5d3738b1db87276b516a1b4d22b9d990a3369aca670374d823a3bf233c5d098fe790e20c7890e8b63def5866d0e81f680edad5314ce7299524364c18026008cdf1e2789f4b7352fdc5e290cf73e7b105af7510f300dbc847d1e42217fd8c3c64be8a07e9998bead1c115acf09a92ad866c2189d05995120efbc74eb746d842f5bb4935b1de247a93283bc6d995bec7322053288d976e145239accac76184aaebceb9c02c8bb9d0becb9f40f8af04af5d7e16e8f56ccd351ed3ff33cdbde2aead75eb83dc81013894fe32230a10a479c3d23137ac3a5506c58ede61e96200de0769e10670daa3999143e829adb6efb0c80a91f6d4aaf730c8d1b3c642d4065e2bf2a40b9c4406dc8b9209aa21a597b0d30e72d406c7e4b8d88d83d279d21e862ecad06b6612ec2acbb2cf701f77ce74edb101c68f82df4a5443445a597fcc165095d966000de68e2bb1b5d00854d8d62665335a61f7ff36be303dacd2a410aab7ab7e21a18d5ae5f8f6d0432c8264344ba0fd6a75f5678fd034543a232ba2f74a00f9926d110d77417ae8749aa0a49bd969f5060ceef957830acc3af0e964ac9801d3f35745914acbca5b52fb2b1f15dd38d81c8fbf48b23733b4f302bd23c55514d24cfa3ec60d9b12f77db542e885faa6ac3e9660f285b9e5de7332b8a70a4c90e83c427b0c8af7ba8d6e1264e2e967a720a27c4d446de78d7b03e247e87e5c7197afccc1e94074176060cd2307f97adf430c08e22bac46378116c4f6d874641486c86fc6557c5bc4b11f0255f142a238a81172ca1eb08284052cf70e09b18d96bab623f872233348944c587129aee7a8f1c28a35c9ef91deac48b1966b1556f7c4f3eb7eda76980307965494d81aeaeb0de8ba826a04b7b9fe428013a2e9f74cc9726ae9f1e14a060c04572895125910a77a5d30c8a7108704e0e2dbc4f10479f89ef08cf3c9241a50182ed072b3ede79aad99be85104bbad8afba72b07a6a04cbbd33e9cf985e15505475a9d06ec8dc91b7da972c5fb70ebba62258c308dda30dfb1d82b8bb1f805b68b7eaf2f1a87383919139ed20d64c787f7d5bd7286f247fff01cbcb57e52a3413c76c09fcd3930cc40b17dadcb773d89aa7b7bfb520b07378ef59d8469d289bdfb51353f86e15992c35ed8eaf95070ea273120cea4fb73ed76bb7cd6177767fcd11997c9798e2343566470f326a7c6c1cc748da338e6fb7e580dd48bc797f1816148a58eeaa2018bb37c591f3078771e9466a34ea9f1638534616c75e3c5d43f8001a2757633a425c7b5bd4a4772c1c41da0626a78c640b0d78e1f4484810334115189e0e68fd64357fb1c9a14922ae82fcda95ea4234ec77dc39e7d70a6f4bee594f3d49f3d923eb905acfdf462212c7341f4a269a20ae024306bcc627ce6c225744b9ebf7f7c5cc1827a642f0aa3038695e8791540b5e4cfa389e0a4627c5f72060668fdf31844b29ba92fcb872153e3f34125c2947e437cfcc7a4b6a8a3f77b00481e7764ce36fa5d9da446714bbb8d8efb9d5ace0488c137404d611f41d526cf577e5b9d097bb6a0594348b12c8c3ac157ee296443759ba3cbb15464e6163a39d0ef30ab62267255194faec8340870f924eb7401d5e37ea9f9094b3e05cade7943875c89bd4e1494efc4ab9f8ca26f40bd62f9aa0ae35e23add3ea563b4617a2cdaa9d30faa7ff7dec9cd0dfa17976291235d91b55b70b7036dd4164e3d35864b29478a193b248d6ab6264002ef1e25a2fe2b7559abf40c0db7c81987b7803fce14c8642a6ed808a56d1243ec484f935ade7b0d58d0dcdc2bac216f938ed8a65de5b3cf2738b8d6c48910bb839480c04cf5e65fd8038d0a3e3023935619b534ea74474e431db6a0f1af934c059b4cc70b7916f6b269ebe6787643f3b902013ec61d7692ef56997c23182fbeb65319820efad9585def3d5b282be064f3c4856e07b1fba7047b39b0c20c8a7743e09c86e8024a38d3de2a1c86a7f0fa9fad00aaa2100802f15c6f09b7cd8245f94cf83d98ee979f39b746ed8882d556fbd3cdd4a588f10a51648b70ba6f76297bb0ed02265fd3381cf79983e5e79637b9e62741d89db6aa59d0332341d598cc02604420c1191a77fbef8a08f4b80443b25ae67786dcd28ecfceae96748d74b58d4f4072616d8099cacc886cfb85df304138ed8262ee4fcedd86bb3535d78ef71ea943f40b8695396be23d2b1071408bff42fd7c66a5d19d24f72116976dfe1bec34efbbce1db556ebe4ec51c0f008f6da4a15437de49afd29360b0273f383d80c535df66294262caa6287fd50d06b9f9ffaa9ee02308c443f2cebc4a32f3972ce2907539970a95d2b01a7fa7aa7708c34a5c3c85223941a47535c375b2f1bc7a1a8867365bdf64e9a885ac8f1012d268eee14e1a41c5b8a684388cb0628bafd8a23d4c0346db6c43f2aae703177b6e15b3f45627babbd9dac51f293432e66613c24e76077b5961d917c871b68377070e83a8cb1f2de483ac99b8c157d68e3366598687aee13e273c28d40d33a3538675df1440e754327c86f058dc64d519dbfdc299eb3527762908ea16be25af4f9c102c8d85223592c8bc858c6dd026363933ae294bdfbac6ca79c21c141e80c55f07454f8146e6215e4793b1dbc43cbaa76b88be202108a5d42dc74fd5ccef26674f2218a1c85011b557846856e7d7f68299912473fbd67994e190151f32c3dc2f590afe0ce31e0000f351e08b9e05286ec5829451754f22969f6d57cd6132fcee49e5cca7abb01e4c9c572f054a12989ce6653f601425950ab32198fc442d488e8ae0dc62d7f5096a8a22253a88c9b931db0c10d8d0e714d2ce500d878f9b67603159979de48b419991a54e0061a5821f792b993e33535879435549668d7620189d1f7dc030d8481b37ee91316470f82bbee33bfebe8be2416d523288f6e7ea4ad09b2c24c2d020c36ed0af4cef4a0716f884b1885ef8cc9e01b56fedcca3793c91cb42bed36eaaa7cb8bd3c51e00c762d3ab0bd18c783d848767cb0dda8e180a6508fd05d6d0a454d01041165dee6598916ae99543bdc220f4ef4ae1e403fee350d1a23ca9f22350878f31603ae955859bf6f85059d90e351de155a4ef10185167fc0c9501bfb3f6df7457911295893e15e0beb0682b9b026be1cc6e1736427e7e818edf323c6ffcf86251538f116c17f083db1ba8c6f33c14ecb32e4d1615dcd3f40200c0b9e564d0914a1529e89f841ae3be3e42c7f4f320a26dc07d24a197cd5109864e1638ff054f5497aa399e0dedf153b2881b119e697db7265a272115d7143fb9cc2e063713857dd0c72934c55c8409eeb6d45eb76e172fd1c8b419bc88e1bb7e47ec1791e63ae2d7dd216959bb09ec6bc27fe07dc13d6d566b4acd414d6a0ecff446d2cc78e4d343f8ae7eba175ed77ff5c2cba98bc98b9c31dc1ab6d53dd5194f80c41e7377e8757ef7416dcc8a74843b58c8f9fcfde90252f7c4b177f96c525c45b73dfc3ad205b75c01b5f25ccef789e86368fa1c50e998451581596ddaa26d42d0f746c0ba99e081c2dce7dc1505bfe405a02ebe7aa3496ef16908221ec827aff31e64ddd5982b78548b19a1f1b3310c29ddc0a75640ca9fbb59d78b5c7ac63dd3e32b43ff9027b5c4baed89f6f90b7c194ecf08378d53f5207859ec4d7dde65b796fc66d39e0198e0a4c4070dd1a7b259fbfbb359745325b4af2297a2c8a32ac1517cb6972fb31a612dfe3eb368ce7890ea83f9b4a999fed180ae076abf98ca4f9ae9f1c2d90113ea090c68dea7d858280745f0b8271541aeef96d1595518d41cf8720df0b7a824f753b1e1eb50cfa52ccae02d8ea6d81eed9bd5a3a75c89000b9d39214e9c9bd69dd98336705eb7b10e387346244cbfb2578f51ab6b251a57ed7ba825c8cc721c1d233d40a54deae3a80fcfed16df0ae8f6545369a02fb626e53ef8f31d560d3946f2c653f1239ef99198b5ed0c5380e7da59dd6f51ab34a550340b5abcca24017fa231d423dd0d8ea89343f322d821877bdf6104c857f35e068faca386ea49c4a23d268a2496b103f763509fbb9ff1728bcc0fc67a898a29c828bcb1b14a5fde604267c902c753f682130596bbd0724be5111e2d463a52b7a3d1bd4ed471d3a492d617b0e7ce3d807c7bb9096449758c854c020ab42b8d35cc49ec93aa646849071b7bdbb1419d30b6703823474896b267f0f7494a90935c5c0cfa8ce2932276392b8ad854ddb8837b09469d9ea80293e70958dccae083b79024dc6b4768acf8fec453fc600fc716447a726f8329b01b81989294c7c0a1ef9f1abac9875939606563ff00ae59b34ab64c8c528d30108f4ed391e1bf52f8c909381b82ded891c58416c315a6c0c643615cf1f0796dca65f1877743e50a0df6b0aa602d80abd86c2e1950a0e06345f642ef5b972e32cfab3aeb174e775f0dcd812dd413fcdd9cc569b0ebcac6d6562f0750eb6ee256c34da209ff1ae5c7b627b6f6944dc9511404ee2442d9bd48f0ebd7641aa859e5a9d5f653ddc9f9b8ffa675a7334e6f06387cf516a084b1b3ba5340d71cbc00f844f76edb912194487f8a757f1333ca9deeae9b0cf18534cf954c31b49a35d76668ae2ae1ede74e10b063557f8955bb87b9681d4b0f286baaf6d2e043ef74ad129070ddca8bebe944288344d08a4e4d646ef14bfcd9c93487ca8a303f0ed52e49fa620da28c4c846d0932c32d1107702948d62e4d7e0cc04c190adc35d41036f4b5e6d7bd4f32f349c7a20549218f4d4cb9be24cc60427edd1d408cd54fb97d647ef57478b9ae595487c7a870ea94a7019fd14cade6aaa952a9ca68791742731fcdaa819df187a320303d88dc76718b85ccc4e75b7abdc37a19b5fbd241d82d05c861b0cfc07e0776dec1b1bd2d9457fcd41fd5ef48bf1048927fced4e315bc0269f0b653feca3814277125fc1f82fa97a598991b8d1390e313da6a80a1b741760a6e26fbfd3d517171cd9824032094da009c4424c47c62b9059f00b328682f96bd6f5918dfad6400c8a970439beb64fc0349024622a54102c8114cdb59b05ccc7d5dd6666b1a7353837400ae2cb535cd4cccbf066f07ba6568d5d54bd71fda17d973af867a2e40a2f350fe8838104d171a21697f58fec03b2c059a79163518dc00a142144bf9ac03f4a7bd922caa2ff22f8e35f841eeb8983424ef0cb5ef1e8c7b69f037c657c27e9c6350a553c88f87b0b8d670af71f9878ba457781bdaa4f227ef8d58d5ef0252233871662ac8d43fe54c637949d9c527c350a999e73145177351a15c3ffe4c99505b33721ea293f54301ab05888249cc8e076bb1141aa71e9f8e6433f819d292c56aaf947c8f786832f3b3c0f5b3600ff6bafdc47c86156bd474309f8bf7f7059d7c4538d7505255cefa33a9c1f9414161cae2230d1d46a415c95d68ac6850417e14a76ea5d7e1ad8d661403e623dedacc125c1aaf2f73ce3f34699b67ec6e7a310ef13203c539cb10b66c92920dfa00546de53b3a64eeb2f0b13e805b447ecdc743ca1912095bd84d324c29e7de518fb4a1a14164ad7e3edca72fb7426d4cc78f0fa1baff7b675c4b8ca3149559295c8b7778e462bb240650a5a80486e2338e59a50425183dc9a3f0716022e1f63d00a84a9fef93bd2430ec8bc338dd16a54b243c5417a9eca91e2b7625f0fd60364d1b071a755f1d51efd9ea1b94784dfc123f6b8752790869e87aef5d8b12aa01361b25331bc1ba91d6d91b7786416e5feaaadf34a236bbc6f956ae5e98dff10225dd53ff5e473ac26593a3ad37fae8d0ea5204293c22541e7ac05871a0f27517f134ef1249c9425a41699a0d21d0af93cf02d44c328a6cc4cef70387143a5db4aa6ba49b5c2033a4e86833ac612a59570adc9fba569b1b398d55c0e47705513657fa9fc607dd1dd406fe32fcce20e0be254dafd3082d6484d7985db08d6c9f22cf2d22a6f2b4399954396daec03c4d0411aea4c3356fb3c65bb52b65b05f5b0a9fb3f78e271fa79d9379fbc11d66b60e6738ceabbbcd76bbc728e75840ca1f7627229526e9099f2a85510283df579c39deaf66f86bc6bda0341c50d0af5fa4c4c4873b86551e564e0ba6d52f0f7f805ab0c32ea03e3c94a33c9c8bdbed781b0f4a51023f7dfd1883b23ea1a8add1f947f0c44f6f64357de0017975a60c6b025300ef80b9af6d7a71fdc4f70fff33c6653f826d4d33cb470a223e5a1e4d69fbc094b9bd7e9decd6e2f599c0f89ac1eb0b7ce18259df6ab257f4881914a074068091381ef87f8400a29559e4a87d8526875da7c8c0ce7cb9f0523351785e3f90c84d653df2098c5dd76705373d3d7cd1e5f4ea8d1f596dfd5204401319348906f78cec245b7e790f4a064d60b845d65a554da303a052dc8d66e693b8a37b6149c7682540cbf52d26ce878e7c3a0e2c4c58eff1eeabf1cd70da6c59a154b0f0e68782c04f4be1b6a1076657db8417d0b41f698edd5a26932568c6bff491458c7f6ea8130b67128ef61b0decf3620788bdd7039291984075ecc8a1fa4fe0d02425c85009c83d506822f8ff911078c19a9f254a977c69a7552a45f8953fad4806d4b37f8b5f8a759de8106629c5cc1f3dc3eadf77c23435167b63d452f11ea0084f39441bba83bf279bd8e088c543244e2f4c8ff1523940c5c1adc559d34372c395d909c4327c964796170786ada7d0d4b4f182f8b86e77acffc79bf68c532195d55fe1e2a9656447fc5d4a6ba16a8f53c01bc39673d4b377039cc7c327fff4a1536210246326eaddcd8d44c61a9e62238d8abd0aa011e9b06556464b678aa91af96af77123c2b7e62c0b84942fef70198969015e98e191671905bbc6ee2c823bc74040ef3134a126975240eb3b41fb1ff62057587283301247f4a09f6ca1ddc74b9b550cd6dd58349addfa5ef9117914c38251d216de0f8294f6c11c5f6208bca504e0483f8d855a7393563b7e3de51d512bbd6a9fe82dc04c8c2b18c83ea0d8bdee70bc55a0bcdc894827fcf46decd69bdca9f49cf867968d548e1b7f99c27aacd8fc8ccc6723c0bad03d458c2ee662a8d3fa7a7eed65629422592f8c9a3a651838140af6b8c8d1109e064d0aa660eebb56bc0d377b76eb64345ecd2f9e42ebcebec2640c5484088d4dae9e9eb000db3d689613c9e0db6634483c91291bcc28bb4bcb738d11f9e9b0db914d513d1707ac837ad64df0294dfab8c6e31543bb56d7ec73ed5241e40f17d8c632e3329fdf9e291b3f3352cbfd0690c1619f79ae7ebbe9f6611a3453e736c85d69df5ec34d99cdff806c638925953c3bf44fb10bd9bbe03fa6f48e66ddc6b13930cf976b9ff13ba8ab92d0ca962e65f7af29cb76cfd89a8a604f578aa7297b336ad76e0f1a3fc9e95b9c120805ff83cfd363ac61e113eb537f75063ec7865d6b35e83701fc2e10912fb6a2729b8508fd9b3162f00d03ae3662f7999c64728a87c64c9c49f909c49db89d2705563e6f78304a8c4942d5589e75d9224163e615355782ca1adc8e8ef3b0a597ffbc67f18d1cb17d908cc856dff0363e8403fe5d4b9c8de5c7be01b429f361c0b42ab662bcd7ddcf8b7c5dd23f9f47cc3673b0ca19b5af82a5b55bea8bfa8572dc12a40e31c672d460fe584cf068b227a87caa99729a3d19726e56045fb2a89329442e4868006963ec170f3ca1a9aded11daec1e6f6f449e0911c2e3288ea46b3fe241b977459d0802080f7d398bec76d79038a839a0d8d6920d15cd526a158ed7d37030e7c75b2851cc76602cf14a0cde4a55ee226e759d8ca1a1238e437923bd45f789b807b50a4b1fb8c78eb7041f002d1779fc6b7be67676ad88716d9209443804a16122f65934b964e492cd566a2cd7b4d5aedcbf437cd7f6855202ca29e8535327a95f9d44e23f9ba84a0425be77cc54aeb2340a8746792ec014f76ae192491e18314ff28b5ca85e35a4db71004872129a1e7b479330b00da103953b785cd8c63cf86aaa4a7435cd071c5040e64800a01c266863073064f714d404eaab9078f27a13c743f5a51ebf65972b8d463a8a56fc8df649911da870d9f9d8a550a180b784140a9f2d4764396e4af0fde42c9443f0a8092ebe599e1afca241e7b44774aec7906b506e2ffd5deb283a20ae3ee10b12e53c629642234a24e94464438b8463df2cd7292771e3041936a8b6924e99b10ac03c8a84ac143019702fcf399f57fffc766e493f64c18febd0c9ef364f35be8adfbbc7c4bff2eaad14c8e107644e2873ee43f5124cc7b7d3ece725d3ded8635c0b9e0245c78d9502dc02e40f99a8d11f106cd9d5e9c8d327dd36c05a4fb6e508eac64b9bfe7cea31b833f41d80393df77006b61b4b4bdaa29c9260974ee98dcca6da6a3968fb6d44b5fc5837ebcd9d0dcd64e755b5461562abceb09ab0b5c62565063449cc8bf9f65401e3b428836e8580423d9da764b1cc092601c2bee74413c92d6beb36b8991bdc7a2b4c20cd30f2905911468ef288dfe6206d90c2ef28693f5c20de60de0b59a1adfe3c7b14eb7973641bd91beb3f3e0f5349701af4fc831fa3d8e6c6e8af2a7e054e2440222dde0913004014f680130d788a2d1af8d521754b4c355973fa7ff9b785c82de010a0bcb84e0af5703f032555b7aba32f371e837ab8741cc94d7906e17d17cf9d1f1235484bc7cb7056439ead5b2ac3e5c3d5e098fdd882d45933bc88c0a464ffca617a38fe4cf9392f10899c3d3fa6d6ef0a2b2de76b91a64ccf510088f373b62f4383ab8339c644feb59b88bca74695fe0f49bea6ca0e4dd46f288f792f4ceb12505f6304419e75676ad3d9002014e49a919da3c48d828d17441565c26128d19f89d159f251811f4b1d982514668935c292396443fa4908aee81ca9cb06d3fe47314f7b8b359f9924fa11af9d51a21082685147954759bd4c75158afbe95f5c52a685a2a155f6b7aed325362382bb7124765c4292258e0d54f77afe74ba68bba377d90a7c4c79ed5c4fb861239b4a275e2178a6758606e158397d150392d6eb46f46e65e37e5de546b10fe98582d12a9b56075e751538e3622d8ebbf448fedb6d1ddeb41edaabe4d2903d4e9edebfda6d5b22a5a286fddb9bca3b82259d3945b8a9e4c84af72ef8a4e8ecde2cfdf9697b37c04ef24b23fc8a72b093b69db26c9d1537c5e1f599ae5db67281f0c4bddc598773755b9d2edb72ae6838057d484918773393a9747c9e05de86afdf501ad47e10e618aa54f4778214e9a57ce0fe7601d14a8ef145f6f9f868350117775db191de979763762ae8f8f26505b119a0d3ed97316fb86faf9a2f8e9882dd71575d5fcef740b0fe78e484a511387a3089fefbdc800947804266a5c84359a1dddd5f3f6005be4bf22f5caeb7293eee5ddf11681b02472a778523afdba0bbc973752bd2831a26d6c02127d8f225f0083abe982b40c409a78b5b4dfe0616a068d9a7b330399c3f5980c2f80b9a4fd5797931ee46b496fbd4367356fa1e120933aba148efa59c64f7a22774bf4edbb2062b7bbd3521a42749a5d969480a77ad5af216ae4a6d4fe5f7334b44c2e33f90f19ec6174678eb5b64bb245f686b3230fbc60b13873e1041e21602d2ec575ecc862258329f187f1bff8ab8753482e91c8f562642f659cc1d3e430a3937b8aa96cb496c05f95ee9fadaa648335c92a628960fc30b80346ee4f9e7cc2910a020a177752a2df581a0f676f1557dc3e50ed2fe370739c867de444be68b3ab71212db149eea384d9d16ac027d8f8bac1146b9b3e33ca0694290615f85fa6bf026dbdfb96f0cdf8dccae83e8f9c8e97cedc19bdaae7f8851c952dc51ddfcc383d3cdea723c49ac0c5044f00dad2ecd08a934916797bc3a43c03f83fea80785c4744a678a5e3b31655850b3b796fed9f75a5df45eabf04b4cba85ceb4753ff331f2fd27e713a9e1109ada681b4bca107846fdbd36889b2900992207f9facecc87f48530e297512e8adec106053715b4ca06fee16eb872ab383621030449a3a1f6d38418aba9f39697fc897fb691052988e9a26f8add3c9daf92b49ccf0e7ca77f747682e1cbe2e157227df2d292ce98b3c3fc077fb4ce6681698376ee29a9253621ac744ea98cb8c6cdc065b24289c3f8f12361a5c1c39c086809faaf922187e6779f3d96be621638f27e43f71b826b502f9d8eac84b5e51f7a9bde0244c3e62eada374fb3703969e26c34dac98206d3962222b359bfcbe5d14cda6a621d0827354de576ef8ca8ee5a18e2827c0eaf2a47d9277170e71f596d633a5ede6635283d83aef85b3459447f925f3e5016210ace808b0b93f7c77a049f025f53a27795a6ed0febd5eee415122c6399ebbb990d567f751d1dc68a4347a211d31a0278b76af95c147963eee31e0d8705cb5d64e248d545e466dd0efda28e0745420ed0d8b0594d98ed75a714ef0c75821be2856e8fb7b374b25deea220be1632b07fcca722e6b21a1d6748cb6db3251552464f37b8867c5246c90901575f6b76b7b8a0d1e6dcaff546c55ae696c005158cf301c64b61c714ee4b8e70b6d8329e917f27ce40828c247b8da2260da2665d5863618012e515ac0b99564c010dfe6e9d8ad866e634b77a0687b2586baa38e1d32e9734e84dcd7a17356a333adaf59d16b025cd3d720af1fb8f60d7afc87abb1258b5b1de53b0ed34826164a0251f2bbeccbb00728bc14d47382f23913b46d90e4e1c7cfb4b846345741cf7a6bb9d7f2e358704f82a473d610eec77e8f38745e4285074e25374a03f8cad37c53d0f196b17af8f56e801d5d01bbc16273c6f4b876a9767f40f3b44fecafb09842174010b517f006af81395c42ae0d82608ad9a49b67524109c0a25eafe0fd69e693e20c0881f94e06bab5cfffac0cdcdc7f6ea5b1fee037753b8457f14ee459d6fea4aa1cab1975b4f9a6b54b87f06dfe339526aa0e81da2b195a8653f2304a1809c461bf94164e3d7a06fbc9f56a652b849ed425768c272a14ca0f3fbcfc437910c1d9a6d9afa0a1e6c3bafd7fbe7f715968924561eaf5ef75c14700a38cdb52b4e41f05d9e973caf75c12537f5991ad9b17858e6e346a01c6320e0ed6af2a2f7c2c1ca9772a3858a61be3124a05f7ef51240da1808e5b9a9dfc0676a10b8ffd971b90736658489a34396de89ccb6019d0b5c379f3a4172c3b66a1c90b068db72fdc299dcd36f6d5e29c92a222c9d9fa0050004668968f09ae4bdb167243e779cd7602a02223980e65674c9babe35ba9ac8eb591f7adee68a9d858a5f0c7887d229c57447e5ca2a8fcacc97db8ae371ce69f5cba708626e73ad6de38ff4789371f9b4f5841303706869a2eacb566dd5f41e6eec707d6e1aca678d149460e30136003e08984fbaad21055f9e82cc3887499c9e45e91a3be4a57713c6080fc9e0b701550fe129badaa38e0729a9da30d6f4f3dfe31daafd8f415964177e03edf5fe45177768c9fc584a0e518b352b33a598508ff7945e422d840191c1254b9a773930b3a9e81e4f8fb3698b720366c6db8412f4a698eb0ad01ff3c0cea142add95442773c410b75d3d0d9ede2a1c1bd7dfed6e1118dd2270bf7344d97a67be31d75cabc86925ebe79386d12e8165cf946a93228d2f469982309edc09a7617ea63f5c076f0d48facbe12af93e8b603731e2a2658eac3be67d8dc25571292f445b687043e41df4a5f3b9410e35ae819298634cb0db5387bf94c1a094e3438c370e02cf79dd1fa8a5de31f39b8ba643920f21198364e8b005dc14865bba5f7bca45efa74033478699e0ab23c3cd320f33a2ca9dda809afa6c95017accfe7e6566e5385e48d77ff12ceb9365ce67d54d02c8416a631c36fe7958f08c04ba6222e5cf00cce59883fd91467af9a27cb92dd4f9d598a2f0cf4273545bb28a4d0b18a54ef603e9793f30465cb16c3274350d417cd9f642f20bee66604ae06a3432f830e862d9cf5c97da5153766ddb8a09827e40103cdbb8c78f36f6d8d5c019a69bdc8e102a164033be0a0bdf5b89fc13446bc48bfaa2e061b6b4ca77b06d2d9d87253ab0077d30704a9a69ec9e6f697627e8dcd7a77b58b0eb34879a791dd6ccaab3b9e25e844015c07e251d582df58c30558a578c914fbe628194462c2483ca77cfdea8e4b3acf422d96a69f524967e517c3bab22914bc292791b7129d04d84dd031d01f9547cbdb2481545fe13d4781a8378883ff2aecf5bee9899fe2aa51ed26b416ff073375e045e29","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"841f49c76df5d0e59aaff76159e1d973"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
