<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88fb5b842efb33bad40fb87f51fc8eef871fce54f79273903c22774226668ddfd4ed2a8b42ec65b0ec5d9677f632ba7a4e869e41f71e331b064e63d16da2027c3d455cfd1251f205b18abca7e009228e6521ebd6126a738dcd5d270a99d304b8ffbadcf9cd47227a75ab95af6c8ef4839abb44e6a540f4db348aa38a54b500253aa2d833556c72aed4af0dc7aad243918a8b4af9ccb7f6242e8ce55a6a6172c34c27425451802e51eed872b9e3967506614f997bacf6f2fb8d0dc3217cfd0679fe96012b94d4291feb85d21f9ec491d7b08d48dc2c7bcfb360e0215fb444eb72e7ac2d1c6a83b94530997cdf3d1c5322e80dec3d9b64ee1331f09ecec8c72276165d819ab5bf1c7d41331d0483ff463e8bbca422575c273f516d868c429c7399d4193c4692077f11a5e1692b928085befea54fdcf6a157d73b4c5fe3dce4f402abe23be64f19db84299273bf85c15b01b5adc0ed2bd4f577010c4f72f2fbb51b2a7833d9d59c857d8df16be17412f77f1342961434624dd07a04072963463c581e1b944317daa6f382d20ba264fc5ff3235e5d982df5edf990d0f1308755f5c9b597e327a21aee87393702dca0002cc827a77380eb9f89b342ac3ae8f31220b62922ccf0d4b02f15d72c3fa6ddeebe4d521d185a7dd46d95deac31ce6ab7742590c3d40879d7e1b51098a4895e3cec57d94b2ea8f3a6bdc9b538812ec4e503b2c81ac3e27567ef0989c0daa483ec394fd409eb3da918b8d66f784d854a694a39b0ecd5c4c99d31b24e50fe3f38e271fe82b65b1454aecf45887209918fb94e9437531f35accdb98c38b39302919f073370442be9d14fd4b7c989446b77251b8ed0f58591c7d4ddd4dda689e2011048f58d0366bb98c69d9778948710abef6e54af67e91644710d4c69551f6877208ac52ea11c89c90bd0a46130c99a29d9baf4a484f41763e065353b75797888170582eaf15fd4d0419176a0f90b296f01c555ea9d575c5fd71700de56eb805d90f707f7e67c4c842c5e906f10c60ff94a30799a26b5c95c17ee391dee72718cf9941c00ae9ae5fdd365cb671dc3616fa6ec1ae0bb34b70468295a7d08351e9be34e3be3a0e452002c3b771d06e6d36312ea0c149bdfb26885d11225bae17ecd382688e535a7f085e119c01a0d3abac52b0b0d725a3a80d904c60e6f2453be104f127f5387e5bbdfdb00012d182abca2afa5e7f6ea025af466c9c0326f66eeefe23b51400797ce2161973b1e1c64c57b54e8ad3624b181c99c9051067dccc3a4c18ac9966ff1e2f1d1227e3da09f1fcdcb765480e1ca5028aed0764f271e523dd73b9879f804ae305d8eaabff78a76c7b641b96fd7034a227d29ad344877178159d771dfe795998d500e3f1aed718270f3f17749fa8d456fe298401e1cece41eec9fefd70bb7fc70191992341b0ed8c65d979056fb4898f15d6c44409befe7dd05b227081d55fad0e15e30ad601682ffb4ec65a3cd65cf9ea787eb794ae1d3d68ce6e86e75f4eb2301ac0a27fad9380bdbf43e91b78e1278057b6183575e290b236d4176403379b07c6bc7aaa41d919866ec169d86ef1df321d4cbaa502be1477ab81a7b25a616b78654b5992358d035377763af78799b5e924dad6b7237da837701aa0ed969d7addce1b4f4a2e664f02124984fe2b21718f700bf57769a7d4495457a6d8ad4c02b0d2cd6153ecd9c3444ce314048c4b9e51ec89c10d78cef91f5e110218ad661c119bd401fd2bed618e758a1581f7f7916b624d61250d5c7816a3a6044e5ca59a1b8bc80dfefbaa21ddd74bf51d0161a3721a8b7826daeaec310e7349d3f89b2238d328bdb233dc7799f47e2968188f01160cca448004a6644b09fec911cff52ca60183cafaada337706164af1e33cdbe29e078364646d8809000670699a1fc71c43cb895ffcfa07c39ed6205fbbb4bed2f15e40f3cc5db1f63b3a8f823f3a5109439a1362f685966cdbc134872af89168f07fa9ec513720b6bde4bfbb4338c2a285af1ba1524667cc00feeb7100ddabdd79e8bd17bbd0939ce49928832e45a4c6fd31ee6621480f202cd14ed497fb48f63913232df9946ec6abfbadcbac7fe301776bca3be3983c55c56ec172f2d0a25e2fd173bb37b9fb418b25511485cac9e1b0a86558f5a55ea2949869f7ff3ce71ff70d1602bb2cfc0df723a1dc1a41d07a1117c219d899fd8e2fd60b5b21fd1db8523a77b97ca049d690826fa9e3d54353e5a39e4ebeb930b342c9d952e2c38ae3609a9ef83ea0a4fba8a33c7d40da4bc80cd2d5acee4e20242e746ed24e43c4d7c53457c722dac248fca3869924f92934fa1caaee38c6ed584589154903d1cbbe9e4c211a3fad5fc385547d7e6fdb62629722e2c539232f1a7b534f673b57d1fbe81c44163b5f7e986a1fc725fed6b7b01deda0eb406ec35f146a4e658308b1f699949dd6921d6f7f6006d595b5a279154f0df8f1645a3a41958818eb125bba1be4a0e42870b8de97ef8bf33ec06bad18205786dab0803af4ddc13e7c3de3cf0c8889ea7dc9186f4ff113d8f961e247c9b6adc341b08209d5183a14e60a9034e596fb32e0e3223a5fbd1c69f4a57958abc446b386e430e69bceb2e2fa93632f740773c5cb0362da15eab0f13eb827040aba240b2c1f601cd599c5f0f64076cf3f71e6ccbae68b141efe0d2f801b54f955c9860f4889821797f7c51d80dc32aa10c48639204dd49f512ff7a8434251571211764bb4992f1470b376c5c20c90da824a7f71bb4b117f19637a1d1635d9ee720dd1d41cef821ba9b2926a49d3e74879d69d3c2acad8c54c5b2b45d77ed3475a1aa5bb16fb5e4d81e2d5116c2ce1abec60060a294c04341d8d0bd5b2be6f5a86e6f65d1f4e2d0bea2337e81699cbc56fd9d7a503bab62ef670c57e1cea744fe57982f82bf7c98f96ef846dfca51deb41c96a2c1471681191666ea076a069f00872ada4631f14844788d2a93e0f66ee4eb153ddf5d7b46dffcc04774695e30161442ce2120085a0dc72baf75de31564b0fa103fdd715884003ddc8c27e908b1adc5ee05e3fd0c1555384adf15f3d5778a5898d5cef25a2ede43ad3df9aeb439b35810ffd16a1030ca5ff76b29c15335fc94f17540383e31e1a35bf4886205380f11ba212d4bf3537d50771c2e402b57408347349a2595a841e47b678a6b77a55c6e6e80f7b342a53b27b62a805c45d97a1a4a95029b3d1fef5e6fd5fc240fb1d20bbc97883e15876bd3fbcd7bb45eff0da8c4457c50b3c185fcc9085d1b801f6c9a01aea5e8eb3606e0a4e29e0fb084d230f58c3e598d51449c63b28651d8784899cd7393eb772655733eb22887c6c9b741368a93a28462441f2e20bfecbdf805dd104982f382c6b447101c6691971c620fb50dd1011ac956b2158fb9acf637985ab4418fc58547d7494666a59cf1c9d9a17a6932a85c16fb8bf5ffefb2e1b6567837cde0fcf208ad6be8403999a8b514b53d074effcdb505a51df1502f89917e7e2f369f816c391822559f683dc5ac85c9c23f932d7bdd080e4ea3c2d5a9f08f24d1f91714130ae82836e8dd021fe135008bc777bb6ddd279b2a526197661023bcf818c43e0998632b09787a2fa29c4fec8bd660902421305c39a8395c6194d4c421edb88d1cb0561ee328b129adf0dcac1371c430456b2dbb687186f71fa5c931a1e42fe7eb4e8a78b3f9f347c057b4b9c3fd3bac1c1f8a8cdb4464d7f585e852646c072757c90b52c3e040437e43c588c4f8d438b79c3d53d294b71d890f3b68d700353043476744fe2e94e23b96cae16824f2a2dfafcc42971047325ac7e577d6505c539425bc42ac2eeec9b7d86471f60e2b548de7169d1c8e20719601c84999c615ac6532a745fbedfff0a053b8b6fa4418b228db49e0b544949ae44cdb32a2041f87ea7682e00b72fe7b60ed2efea7861a7c09feeed90f785eb845cb4f828fd665f14540285fcab41a1ac646255c5c415419dfdba9fe56c55248cce30c804a7879a3e50dc8ae8959ade7b184acc9c476aa60389f27044ad5b44915c666487ff7b440b03250c73fa1c07512437e5abe850212ff58cde02b1f810b8fb59ec7ad45886abe816332382c4ad6980ae6107a57fbe0d5af8281bf4c067227801affa9ced5b072df6b3aad6f857f04a48ed03c0075c35e38e3ffc36b0b44cb3d2852ff2e24022968374171d3ac1589ff32e2b3ce5b052310f9d8ab6f524efdaeda64970343bd219cb1ac451a6670c612caaf789db90d1f97a865d60cfa2f57bf781ba34ff5ada8a0e19510dbba88c4482819cbf8991f145dafc75a4da856f3b53ca450faadfccbbe84a41d9ce5263af100a208cc308f11489219f403ef0c19349d6e362c66803006a727fe03b12259e739f860512ad3c308c90e7deb6e6fb2d8def894efa26802cb00248e4eccb42bd485655585ebf37673faefd137fe175bb7f5bff4cb9105029c008addbe07e96c0222dc4976faa17d8d87d71931cb419e550936edb545907608c2f0a4ee603fb21c0d681c2794e2b722d24b265e81931f0e9c1acdc848a91616c1dc32d4ddebd97a51a0f9e5e4d0a52edb663d0ce25e88363fd8f227b0eab430ab5739ac171f43d2be080709180887daef7982ad30ffc8c619c1bdf012deea4076a38e5ba27370ff81b963443937b0dcce6dda1794349b414a38d9197949808e690d99f328780fd5b1d3f70c8bb596030d7e02f5b1c3e6cefd84cd13bb896aef6a910007adcfb308f1913a40693c1d56e8c390d240715b46879b777a0d97109759272d4ca7fedb23281baba78754215f1c60318bb9b9c4dd83cae5bc5c279145be10a9dd6db236d8b0d1ff5283da2d968c3883985c62ae9ce646a9c6090122519e14c3a9952c3f2f61c847a2e3f4a14a09e252a1999110f5379829ba02288a40df35ae7910a9129817f309c64a501e5786b069d415c2ab9e938ee61690d11cdb03cb77b89022df71b3fbbb4cd57894fbd10c95530fe797a83f2b9a9f22e62b1433ccb797b5372b926dd4ec9d8737ff8125339f05c1fda37c2b67982dad252350964b43608298ae628f3e69f56f340140bd9cd351d5e01d9a95c7bfaf3c3c3fd74cf1de8b8b41af78e10619420bb4f2e41022f9fa730e894d22c23353cd24dbe4e7d0cdc6c2f155a172684ddd3fffb9b5a9a75d7133c772deb2e53cb0555c9f872a1c00678922d50c8b1b11d64edcc87327f51227b44be84f75a2e2adc8ffea9794ecbd944d69bbc0c4078a2d6eb9b46d0271e0cdb109b3cd3dd1cc773cfa1c4bcd611976fa8ebe916c8be964286fbc39e6bf2460033266c4da833c397b5777665968de0848f48f4c47806d881d436a5935c5b0085702e02a1e9c2e312f33f747c2fc5e24a38b7a53eef93c80aaab70b88e6e134fc68c626bda988fc4695e3a725ef3aa536a864de41bcec4778ca951175883fbb228c3bb36240183314b91b40f63b2b6514135a11edc9b77f856ded6044b1204750fb56338c4c724c97197bfadafe36389dc42f7156ee3cb089daf7b77c284abf16c7e9303a22123924ad41d43beb1b2e077c03d8c0d9aebfe39a390415b9fc4a8c4df9c69012594f480f4f4d46752cbde1e60af55fb3fd4cdfc60682f7d5ffafee1b6d2499a06e6ff5e527b1b086ae57cf235636e445484bdbdaa26020134d7135d646d2b64b6aeba84c85e55531e22b375cec2845c13ba2f6702e496952e3c906b9551de398a55be30b242f6cd54640d469501e7d8a3d66a89ed493e4157d99f86f92a0ce191750df52cbb668628800507ac0e9103cdfcc2cc2d368264073e3fa66045cf7de085ca08eeeafdb10fd9cc709b58888d8d1b8ee8784bccd7207c824c18a95dfecea1307c5932b20c3d41fc87aa10239536c64894c8f0b8dfdc648a9f554ad646fbc7ad486b7c041dd92d46d9c1fc2c3198122a056057908608d1d6190e8a03855bd404cfc8a3c43423d47538378b761741a41985e25e1cac29051e02c09dbe5f4b9d2e5c3acf37dfbe6fbf893d8b063012b6f6469c31709b384f9095783027fae2e53c88f515475ad269e569ea0c4a6668644beca234af964b9e7e5be10d2f82d9fa3cb96943efbc0b46e8810217f8f083ae9097a29581888a88227dbbfc13e791f089c421ab7bd88be9835d02bde02a144ec9ba9ff70d3143a45b55a99d218f8b6505d7b098e6280533691caa9d113216fa32243b3552d3e8e619f8b3c2e93378e2e52b6d3bd783246707142ec21d6a03b2329619008bf336cd56e7b9144f5544f2bef192e9c712493736c37f6c0ac4a0e68d56087e846cf1f0918a4daf3c02b1e46b330bed98ff22941268c8b8880a32bbc2c6dbf5062ede78f2486c94bbfbbee52ab6d524f45fabaeaf2a077aeacdeca143d8f085f638c4a257b116f9b5442c7da2cb43aac83e389b2a17b84c3a0c51692061214dbf57da2362e4946ac236f7b2f572fecedcb203ab0ea38c6d099658cdeff5431f4945df8b777b4662d3415403b3dcfcde07c39b09198d245aa86766a2cf8a2486434dae2f11b1c56847781337a015486bff2671265ca3ae01cd364f287b0baa5f2dfa3b74f0a488c6ccd42542b3405014aee1be9708195a913b4f1721f00eb2175084d367295d8fbd460acc8cc02a62df30e4be26ec90bf7b81b67860b200989fbde4198f191968d4ad6d7b497205d29db4b6e4928487a6dcacdc59dfda266c96aac5a02ea21471ebffac8db4ddda86a50dc11a9d956ff89fa6f83b05f1a6642b870f9d1409b60fa6313c59be0bd69a5e4e1a20b578f1f10aaf9fcb5e32b6355db538b4532fdb088de7c25ae958485ab34dbb9e51ee14b4e86dd5a598ab7d3f6cd327c16aeaac0e7f447e9c4fde37f382e560de8027049bc3381545d0c5f3744917f8677feca156c5eac1d68efd047808be74ee32d91db76e09be8526a75f447352e9ce08d62a762caee6ed1363989ed242ad2420e8fff571e33409adf8c95a4495bbd5593db2285650592f25196c615099beefa7b616beec04fdb248d1c990bfa0b6692a3f77af7ece39d5977a533672be02e8512ebb1830c64318c21b7451f193e40bd8e9deb5fa52d69659d6e731081fed7dc3c9a5bcfc9af8b0b0c48919fdf4d4b9285c8f5c9c8282b1916f208b5c8cfdae04edd858b5df277006b9051271b9228555efb5c73ee9de867c1479308e15e26358325f2f23f8f7e56e838a3204fbed11f535ab5b171b3183fbdeb38691eb6a3db6e7b89071a451943e3712d0d80b780e17c8e0d8ca959f1dbba677c2f8d55dfe35b3e89c1bf121abbc12669f1cf0dd26e69644a29763650caf3ab504c85ede98fc6539934426acebaefba3583c6328ec5154df000c3860d15d62c85f1b6ee855ff8e56f012d23ff86ac8463e311cf40ba81465be2ba0b924341eba95b9dc991af8716fa295a4d18e3a65467a63102ba6a629399e2d19696691b17d59b146bf47422e168fbcc8a6850102b875f8d129041537b40da7603efc078005bb17d86e89fa09d5d8ae018a26b9485a11da5cb651433137fed41ef48ee6205cab3e3a19d46d7dc735a83ca42d105704d7f81707d81d8d0b97c595b1d7f1f99552368d473bb8d084084d391f06194404edeb79473788c76b2b72fff745b1a5028e5a40f9212cc66ad6e4d641ed2c32c0f270f40e7b41b709ce601e5498eeed84bd46fc8178b91e304828daa8aae42dafcd3507dcfce92b4a76e288c2c576100a0967c46a93f96ed7bdd6fb8dce47cb2a13c23a2e4df10b754c09d798e39ef2637e32185df0a887d06e0d11e330c530e1ea420c0bae66ac08535d4c3f75a4e88f65c6d11d0b50f750c368400d0b1f1b18e6e96dc49cf852bb47abe523e374e90cfc7fe0906e54be7d76c842fe9570eb71c9ed71585770b1227d3fe5d15fd00eb7897ecbeb2adfa388982395432b6f56d1a9f3c1e9ce7458a28fead3352631c97c0e372c9876de9e820111dc7b4a4d469856d8aea636da54a0f709f4b790c997fa08323c3bb2023e2620f4fe2c536c7c2faed37b8ad6a446ffc62e0fe63b4827e7da08c139f28e22fe2ae6e243ed14a21d2dc3488ae8f32fc0fe710999cb8e407d7adc18da14fa8afbeaf0b0c2eefa45dd4ddb8256e6b626d57d3d8c58be0d3ad3461d9c1e716f10b5b69cfb6b3d3b8b0eb03c529d70fdfc572be6b73ac7a87ed7ea16a871c4be3d10d9c52fe8598ec4241d6191ca38426b1ca698625b7f3b110969fd62317b0426f2d2c9f96fc1b411bed63ebcd340ede015ec7c5f3387a74603fe2ff4ff16d16f5cf139c76540c098527842c4795ce57b380862327784ccc25e9d8406fc851bc7faa78c6c4dc07bb9c2f5218780a13452cea6af67106be3b82ddb839f737e8ac7dd21440bde353014ff765f540873bbcf80854f257ca1c3a8ef648f1f803dd901b0d4f746c602da4e39e73e9af7a4b4646e3a3031f814f54ccf12ed4c79a1bc03b210f3d5c64af7ba1e888fe07337d7fe8b32eabc1c0adce0d51abfd18bdaf9ecc429116acc9b5fffdae4197fce84546655049802df8a45404c9613e3329c6b375b9e341a2a7195d282d8225054d553bfd5fbaeb71a7cb63df826459e657541f93fe745e351c84ce0c7b2414cbcf736fc611b4e943454640c9e6001cc8ac88b2f022496cf437a21b1ba172c1ea769cc8a645ab65331faac7e58f3a8679e34f26888e83e0b52f4cb373abe8929ac688e22dc63fc8ade5fcb050d5319b937c6ca69a43ce345763f84be8bcb645177c03c44dd347b1baf55f800500a2aee7318f4a3dafdb6a359fe303077a202f3b5ba54894164393b704d964000716d3763c591a3b85055ccacdd6242dabbd3936bc12c43262a385d56e46d445afe770f8a0ade59cf0e31622877ac7ba0ad2a7a3ac05b927fb35075892769f29dd489e0fa7d4d8cbd7ca4f8096115b531008b208a3caf92740603eed8a7e2937b4e6f45a52195d076c2e94a0c497768fd557298e17c4e54fa6f0b0a88f1a0014e7a612789d7c8565ea599c7c55a61010a54bcc46b079828c4736c1cc04b133368937ea9bb848e7c070c2272f09b976d2001e7af2a9f81f38cbcc8ff3da5df70c79cebb4164439818f80d721f4934228b1980a885e42e6d100048854fae56df4cd74225176deadaa9a03f1d04dddbc15b13c164dbe347f94f4f0f1a666562013e3309afd3df47b1ebf6586c4c02f93c86f7c3356006d337dffd42c8b7f47d43bb74aa9d2179b6037e19dd639ac90b1179cb7fb5301d8fbeaf3b1b30d9ab6de18ac5d23b9c5db834d889340db29a5db23fd28026948e93a4e93db57600529009d9dd50362895122dde70f97fbd979c921bff5c240dbc06f302c3c5faab5f9aa8a390f8381f44ab27d9953376cb305417d06f1e76ba77af247c4c0078037b9e30c2555e38eb32ee412f98b1e2eb3a53347a2861260bcfca52037b13cd5d858b13621ae4f86c194d7e4b3e9dd4a65e6ade5dfc3ed6e2e647737cfda4af53a21ef259c043199b15f3f0431d9c2dccb85323cc6a8defda0f6b97ad0e451d6327d06689129352a1ea3ae99f02f41ea2f8db344ba21d82713b1a6e9e05f9eeac9b415bf75873d506e31921bb0abe559847c94f548f3feb9d9e14180f9e93e1b3d7cdb0e8d5c1dc0f5044dd4fdb2208c1d80e77ff89ad7470a77016c88c713402d3c405d26fe7be13e0174125f8b316dbb3bbe33ff202cc86eae176a0ce40dd8a012198809458867ba1f1aa3cbf89253e31e03b472a61ec745ed2348527ebeb48c580cc57c754dcb72971417604c18d649927c50b11a5f2300f3b75a3699c207c6b18ab8a50f9358c6889da83dbaa5a7282412cdaa75867aace857890287dec0a3c2c06935873df2e91e628ae58c985fbff5b57fb7244f3f460e05dd4edcfebbe6f1945dd3b02d0ee5f795707438fef8f1275a5953ab1550dbd5e9164f4f465e521051bb2c09a37804ba1db5fcbd67c9580fac5f76758a37593fe62ffb03db7cd6c246679823a10dba4fad5f48b2de68dc98e3a17e394bec3e303f3789f472fed88b370cf68394398d36cebdeaf0a049d98458a29a032dcae3fa7011d0fedd8e501926a7e4033e3e8338c1eb60a46335b123d4dd5b2c9dcb8c28ba2bbf4b4e6c9d4796fef58152eeecbccdeb8df535d65b48b3707a4584133ed9a518e48e7c3015c2399e3e928d7b27eaef0cd04025d5a5d7c41357bd67d6c54df2772679b992a4bce73af58995f4ecc0d7774b0ae8e414225c2eec050e677fe899d5ee88f480e0e50bc067d07f165e35f484d4213de445258f2c710320605e3864ab87b4b6eb5b9fde575d3fa7483d682f249806cae9ccedf094d5492eea6a5dba1d5915c70e29a1f003f9871f921b6c1d600c015d61551df1ccbec5b8937686875673d23c00c04df2b61f910ff93d5a6a19250f8a894c53bbe880387700b0ea3aeb8b3d13e60f99c3d75e6ef02546000e40f74cc2366b0c8f4e1d6eaa825967f4f44de3df3a3f967eebb249f7c180db9e26dcb4d1f23b2f37ba44b192457fa980b5744da3f7b3166cf1f6ff9e46a1d05326415b8c3c7fa575418ce27be2e33e363fd032c97ffa836016aa2492ad6e87821ee7a487d0efde47dee3b2ee75bb6e3f481a486ee8ed6027f66e7b717765b416d645b9584b7dc39f7671eff6dc8de0a5d6297c2415b9f07979ec779241cfca382946b23262198cfa7d9f5cb7ca99d3ec58fcdedd31ba71c764e7ad7743f9b39af7ef94cbc6921363c2b6d108deb4bc413628d70a0ffc4035135878480d12c0fa1a08a90a0ece32db732633412040c26060132248d7184ef99e1a5b3d3dbcb5cc0dd10e380b93da48a7922fbfbaf2950a64a04d138a7569e203b97c476e75e894a6cb3d0c50a5810cd97c633f08db6f8409d121091d227f247217d8012b41688a21c3bc5e7983bf3fb3e9a404c4085d117e1c8d2856ac94c3d57dc4e211c4b1e116fa333deda297b0ad34dcd8345d747308eaf4693a85c3bbbb163c6953b575a993097bbdb5a39384c9f9b37e373f1385e80e89cc15f78e940064f94b87423f01cb0af63e6dfa8ce46098562bea4b156f07cb891adc4e0c4b40411a29a13fe517339fcd3bf7d980d8ce4c1c3195e849ea6a6e3ee7d234d49729f406f6c6a59ed064b2ee14a82e5be6b5425beee4fc79fbf76102e5041dbdc0f63906377d752cee94bbb78cdc5186be889631531425507c214a151f0018802169d1129db90fcd40b8f427c955f60324a74910dbbee178735f6aac3f9adc1435993ce2be69388f04394ae68dba22022aca0ef5daa0b8d93d3f131aab4451ed4134cca5fbe5f982a1af70cb5c43ba1fe07801fd3e38af2a90862495fb1f29eec47006a90e743cb239ede908679e9cf1718b4ba09867a40c4de85b3a8c65d6bea08e05efbeba00845f554e03588f1e350ba7ba61534c2b3f5d8a9d216323c37ea295f2f51fd6df2696319afe7b39b00e62c645b6ba3243aba8ff71f828664babc095416ec5e565c75c37e559906a6df584eb3930d7e994241aae3a144b7c44d29c9ca573fa47f5ad104108d7c32558de74423f9556dbec8390e0b7aed7e621877dd2f2729b24ff15a37e170faf6900b387e797ec3b73fe728496ed9508bbbef2455c7141bf57e7a5e8b61ba0dea94714b3d9e152aaf4fbd78a4372317779f0ebd5057603245e86fb8f94b18e0e83303b931ac25082a8f5ee2c3ab26acfd290cb345936edfa9b7cca009bafeea85c51466558bb4952cea4fb5ab3948c286dff83c8e2dfd724775d4b80482dd04707894930dd0a0e600c45e708a32fe40434361bfc6e10d637394504162063d50c74677ad3bdc0ea1ccdd5d5271b0c3ca4cdb5dbd8cc35637cb058c718953cecb3d50243011e6a316a026b81b09f873d29e2d2a5e3d049c4963bb1f1698da4e044cf642762f8468f63247eef5d84fdbaff8006fb0f850d7cfe7f4a01b6b8e1925bbbc2a70fdd4db4ac01daa61878a00427cd2d3b8fe7267b37769234d506089555fe274d11b5ffaae323f482f937e46fb18c3e2cc5c4a0ab0cec69ae91611cb1027b1b2b39cd1f423b3e046552447e883f3cd0e894296431654bbf1c2e811954adc29a20252c2e5fe80aade6cea1a73183955fb69fcadb12b132b4fd43a98fd0cb7047a25012bdea1eaffccd8b4be233bc2e05c9f576f0e4b30618345623","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"26c6f28c0289324ceafc81f6e41e2e13"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
